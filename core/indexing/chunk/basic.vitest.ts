// Generated by continue
// core/indexing/chunk/basic.vitest.ts

import { beforeEach, expect, test, vi } from "vitest";
import { ChunkWithoutID, MessageContent } from "../../index";
import { countTokensAsync } from "../../llm/countTokens";
import { basicChunker } from "./basic.js";

// Mock setup
vi.mock("../../llm/countTokens", () => ({
  countTokensAsync: vi.fn(),
}));

// Reset mocks before each test
beforeEach(() => {
  vi.resetAllMocks();
});

test("should yield no chunks for empty content", async () => {
  const contents = "";
  const maxChunkSize = 10;
  const chunks: ChunkWithoutID[] = [];

  for await (const chunk of basicChunker(contents, maxChunkSize)) {
    chunks.push(chunk);
  }

  expect(chunks).toHaveLength(0);
});

test("should yield no chunks for whitespace-only content", async () => {
  const contents = "   \n\t\n  ";
  const maxChunkSize = 10;
  const chunks: ChunkWithoutID[] = [];

  for await (const chunk of basicChunker(contents, maxChunkSize)) {
    chunks.push(chunk);
  }

  expect(chunks).toHaveLength(0);
});

test("should yield a single chunk if whole content fits within the max size", async () => {
  vi.mocked(countTokensAsync).mockResolvedValue(1);
  const contents = "line1\nline2\nline3";
  const maxChunkSize = 10;
  const expectedChunks: ChunkWithoutID[] = [
    { content: "line1\nline2\nline3\n", startLine: 0, endLine: 2 },
  ];

  const chunks: ChunkWithoutID[] = [];
  for await (const chunk of basicChunker(contents, maxChunkSize)) {
    chunks.push(chunk);
  }

  expect(chunks).toEqual(expectedChunks);
});

test("should yield multiple chunks when content exceeds the max size", async () => {
  vi.mocked(countTokensAsync).mockImplementation(
    async (line: MessageContent): Promise<number> => {
      if (line === "line3") return 5;
      return 3; // Mock returning 3 tokens per line except for "line3"
    },
  );

  const contents = "line1\nline2\nline3\nline4\nline5";
  const maxChunkSize = 8;
  const expectedChunks: ChunkWithoutID[] = [
    { content: "line1\nline2\n", startLine: 0, endLine: 1 },
    { content: "line3\n", startLine: 2, endLine: 2 },
    { content: "line4\nline5\n", startLine: 3, endLine: 4 },
  ];

  const chunks: ChunkWithoutID[] = [];
  for await (const chunk of basicChunker(contents, maxChunkSize)) {
    chunks.push(chunk);
  }

  expect(chunks).toEqual(expectedChunks);
});

test("should break up lines that exceed the max chunk size", async () => {
  vi.mocked(countTokensAsync).mockImplementation(
    async (line: MessageContent): Promise<number> => {
      if (line === "line3") return 15; // Making it explicitly exceed max size
      return 3;
    },
  );

  const contents = "line1\nline2\nline3\nline4\nline5";
  const maxChunkSize = 8;
  const expectedChunks: ChunkWithoutID[] = [
    { content: "line1\nline2\n", startLine: 0, endLine: 1 },
    { content: "line3\n", startLine: 2, endLine: 2 }, // Including line3 despite exceeding max size
    { content: "line4\nline5\n", startLine: 3, endLine: 4 },
  ];

  const chunks: ChunkWithoutID[] = [];
  for await (const chunk of basicChunker(contents, maxChunkSize)) {
    chunks.push(chunk);
  }

  expect(chunks).toEqual(expectedChunks);
});

test("should handle very small max chunk size correctly", async () => {
  vi.mocked(countTokensAsync).mockResolvedValue(2); // Every line is 2 tokens

  const contents = "a\nb\nc\nd";
  const maxChunkSize = 3; // Only allows 1 line per chunk (2 tokens + 1 newline)
  const expectedChunks: ChunkWithoutID[] = [
    { content: "a\n", startLine: 0, endLine: 0 },
    { content: "b\n", startLine: 1, endLine: 1 },
    { content: "c\n", startLine: 2, endLine: 2 },
    { content: "d\n", startLine: 3, endLine: 3 },
  ];

  const chunks: ChunkWithoutID[] = [];
  for await (const chunk of basicChunker(contents, maxChunkSize)) {
    chunks.push(chunk);
  }

  expect(chunks).toEqual(expectedChunks);
});

test("should handle content with empty lines", async () => {
  vi.mocked(countTokensAsync).mockImplementation(
    async (line: MessageContent): Promise<number> => {
      if (line === "") return 0;
      return 3;
    },
  );

  const contents = "line1\n\nline3\n\nline5";
  const maxChunkSize = 8;

  const chunks: ChunkWithoutID[] = [];
  for await (const chunk of basicChunker(contents, maxChunkSize)) {
    chunks.push(chunk);
  }

  // Based on our current implementation, check that we get 3 chunks with each line
  // starting at the correct line number
  expect(chunks).toHaveLength(3);
  expect(chunks[0].startLine).toBe(0);
  expect(chunks[1].startLine).toBe(2);
  expect(chunks[2].startLine).toBe(4);
  expect(chunks[0].content).toContain("line1");
  expect(chunks[1].content).toContain("line3");
  expect(chunks[2].content).toContain("line5");
});

test("should handle content with just a single line", async () => {
  vi.mocked(countTokensAsync).mockResolvedValue(5);

  const contents = "just one line";
  const maxChunkSize = 10;
  const expectedChunks: ChunkWithoutID[] = [
    { content: "just one line\n", startLine: 0, endLine: 0 },
  ];

  const chunks: ChunkWithoutID[] = [];
  for await (const chunk of basicChunker(contents, maxChunkSize)) {
    chunks.push(chunk);
  }

  expect(chunks).toEqual(expectedChunks);
});

test("should handle a sequence of oversized lines", async () => {
  vi.mocked(countTokensAsync).mockResolvedValue(20); // Every line exceeds max size

  const contents = "line1\nline2\nline3";
  const maxChunkSize = 10;
  const expectedChunks: ChunkWithoutID[] = [
    { content: "line1\n", startLine: 0, endLine: 0 },
    { content: "line2\n", startLine: 1, endLine: 1 },
    { content: "line3\n", startLine: 2, endLine: 2 },
  ];

  const chunks: ChunkWithoutID[] = [];
  for await (const chunk of basicChunker(contents, maxChunkSize)) {
    chunks.push(chunk);
  }

  expect(chunks).toEqual(expectedChunks);
});

test("should handle content with varying token counts", async () => {
  vi.mocked(countTokensAsync).mockImplementation(
    async (line: MessageContent): Promise<number> => {
      const lineStr = line as string;
      if (lineStr.includes("small")) return 2;
      if (lineStr.includes("medium")) return 5;
      if (lineStr.includes("large")) return 8;
      if (lineStr.includes("huge")) return 15;
      return 1;
    },
  );

  const contents =
    "small line\nmedium line\nlarge line\nhuge line\nsmall again";
  const maxChunkSize = 10;
  const expectedChunks: ChunkWithoutID[] = [
    { content: "small line\nmedium line\n", startLine: 0, endLine: 1 },
    { content: "large line\n", startLine: 2, endLine: 2 },
    { content: "huge line\n", startLine: 3, endLine: 3 },
    { content: "small again\n", startLine: 4, endLine: 4 },
  ];

  const chunks: ChunkWithoutID[] = [];
  for await (const chunk of basicChunker(contents, maxChunkSize)) {
    chunks.push(chunk);
  }

  expect(chunks).toEqual(expectedChunks);
});

test("should handle content ending without a newline", async () => {
  vi.mocked(countTokensAsync).mockImplementation(
    async (line: MessageContent): Promise<number> => {
      return 3; // Each line is 3 tokens
    },
  );

  const contents = "line1\nline2\nline3"; // No trailing newline
  const maxChunkSize = 20; // Large enough to fit all lines

  const chunks: ChunkWithoutID[] = [];
  for await (const chunk of basicChunker(contents, maxChunkSize)) {
    chunks.push(chunk);
  }

  console.log("Chunks for test:", JSON.stringify(chunks, null, 2));

  // Verify we have a single chunk with all lines
  expect(chunks).toHaveLength(1);
  expect(chunks[0].content).toContain("line1");
  expect(chunks[0].content).toContain("line2");
  expect(chunks[0].content).toContain("line3");
  expect(chunks[0].startLine).toBe(0);
  expect(chunks[0].endLine).toBe(2);
});

test("should handle exactly-sized chunks correctly", async () => {
  vi.mocked(countTokensAsync).mockResolvedValue(4); // Each line is 4 tokens

  const contents = "line1\nline2\nline3\nline4";
  const maxChunkSize = 9; // Fits exactly one line (4 tokens + 1 newline)
  const expectedChunks: ChunkWithoutID[] = [
    { content: "line1\n", startLine: 0, endLine: 0 },
    { content: "line2\n", startLine: 1, endLine: 1 },
    { content: "line3\n", startLine: 2, endLine: 2 },
    { content: "line4\n", startLine: 3, endLine: 3 },
  ];

  const chunks: ChunkWithoutID[] = [];
  for await (const chunk of basicChunker(contents, maxChunkSize)) {
    chunks.push(chunk);
  }

  expect(chunks).toEqual(expectedChunks);
});
