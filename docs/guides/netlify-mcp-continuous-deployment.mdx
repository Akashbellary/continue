---
title: "Netlify Performance Optimization Cookbook"
description: "Optimize web performance with A/B testing, automated monitoring, and data-driven improvements using Netlify MCP and Continue."
sidebarTitle: "Using Netlify MCP for Performance Optimization"
---

<Card title="Ship Faster Code, Not Slower Sites" icon="gauge-high">
  Use AI to automatically monitor performance metrics, run A/B tests between
  branches, and get actionable optimization suggestions based on real user data
  from Netlify Analytics
</Card>

## What You'll Learn

This cookbook teaches you to:
- Run A/B tests between branches to measure performance impact
- Monitor Core Web Vitals and build performance metrics
- Automatically block deploys that degrade performance
- Optimize build times and bundle sizes with AI assistance

## Prerequisites

- GitHub repository with a web project
- [Netlify account](https://netlify.com) (free tier works)
- Node.js 22+ installed (required for Netlify)
- [Continue CLI](https://docs.continue.dev/guides/cli) (`npm i -g @continuedev/cli`)
- [Netlify MCP](https://hub.continue.dev/netlify/netlify-mcp) configured
- [Netlify Development Rules](https://hub.continue.dev/netlify/netlify-development) (recommended)

## Quick Setup

<Steps>
  <Step title="Install Continue CLI">
    ```bash
    npm i -g @continuedev/cli
    ```
  </Step>

  <Step title="Configure Netlify MCP">
    1. Install Netlify CLI: `npm i -g netlify-cli`
    2. Authenticate with Netlify: `netlify login`
    3. Visit [Netlify MCP on Continue Hub](https://hub.continue.dev/netlify/netlify-mcp)
    4. Follow the configuration instructions for your editor
  </Step>

  <Step title="Add Development Rules">
    Install the [Netlify Development Rules](https://hub.continue.dev/netlify/netlify-development) bundle for best practices:

    1. Visit the bundle page on Continue Hub
    2. Click **"Install Rules"**
    3. Rules automatically apply to your agent
  </Step>

  <Step title="Verify Setup">
    Test the connection with cn CLI:

    ```bash
    cn
    # Then in TUI mode:
    "Check my Netlify auth and list sites"
    ```
  </Step>
</Steps>

<Info>
  The Netlify Development Rules bundle includes guardrails for:
  - Proper `.gitignore` configuration
  - Function structure and placement
  - Edge function constraints
  - Local development best practices
</Info>

## Performance Optimization Steps

### Step 1: Baseline Performance Metrics

Establish your current performance baseline using cn CLI:

```bash
# Start cn in TUI mode
cn

# Then ask:
"Show my site's Core Web Vitals and build times"
```

<Info>
  Netlify automatically tracks:
  - **Build Performance**: Compile times, cache hits
  - **Runtime Performance**: Core Web Vitals, Time to Interactive
  - **Resource Usage**: Bandwidth, function execution times
</Info>

### Step 2: A/B Test Branch Performance

Compare performance between branches:

```bash
# In cn TUI mode:
"Set up 50/50 A/B test between main and feature branch"
```

<Info>
  **Enhanced Analytics**: Combine Netlify's A/B testing with PostHog session recordings
  to understand not just which variant performs better, but why users behave differently.
  See our [PostHog MCP guide](/guides/posthog-mcp-product-engineer-cookbook) to set up
  session tracking and create a complete continuous AI analytics workflow.
</Info>

### Step 3: Optimize Build Performance

Reduce build times and improve caching:

```bash
# In cn TUI mode:
"Enable dependency caching and optimize my build"
```

<Tip>
  Common optimizations that Continue can implement:
  - Dependency caching saves 40-60% on build times
  - Parallel builds for monorepos
  - Selective builds based on changed files
  - Build plugin optimizations
</Tip>

### Step 4: Bundle Size Analysis

Identify and fix bundle size issues:

```bash
# In cn TUI mode:
"Show largest dependencies and implement code splitting"
```

<Card title="Automatic Optimizations" icon="wand-magic-sparkles">
  Continue can automatically:
  - Add dynamic imports for large components
  - Configure tree shaking
  - Implement lazy loading
  - Optimize image formats
</Card>

### Step 5: Performance Budget Enforcement

Set and enforce performance budgets:

```bash
# In cn TUI mode:
"Set performance budget: LCP < 2.5s, bundle < 200KB"
```

### Step 6: Image Optimization

Optimize images for better performance:

```bash
# In cn TUI mode:
"Convert images to WebP and add lazy loading"
```

## Continuous Performance Monitoring

### Step 7: Real User Monitoring

Track actual user experience:

```bash
# In cn TUI mode:
"Set up RUM tracking with alerts for P75 degradation"
```

### Step 8: Lighthouse CI Integration

Automate performance testing:

```bash
# In cn TUI mode:
"Add Lighthouse CI with minimum score 90"
```

## Automated Performance Checks

### GitHub Actions Performance Guard

Block PRs that degrade performance:

```yaml
name: Performance Check

on:
  pull_request:

jobs:
  performance:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Deploy and Test Performance
        id: perf
        env:
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
        run: |
          npx @continuedev/cli@latest << 'EOF'
          Deploy PR preview and run Lighthouse.
          Compare scores with main branch.
          Output JSON with score deltas.
          EOF > performance.json

      - name: Comment Performance Results
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const perf = JSON.parse(fs.readFileSync('performance.json'));

            const emoji = perf.score_delta < -10 ? '🔴' :
                         perf.score_delta < 0 ? '🟡' : '🟢';

            const comment = `## ${emoji} Performance Impact

            | Metric | Main | PR | Delta |
            |--------|------|----|---------|
            | Performance Score | ${perf.main_score} | ${perf.pr_score} | ${perf.score_delta > 0 ? '+' : ''}${perf.score_delta} |
            | LCP | ${perf.main_lcp}s | ${perf.pr_lcp}s | ${perf.lcp_delta > 0 ? '+' : ''}${perf.lcp_delta}s |
            | Bundle Size | ${perf.main_bundle}KB | ${perf.pr_bundle}KB | ${perf.bundle_delta > 0 ? '+' : ''}${perf.bundle_delta}KB |

            ${perf.score_delta < -10 ? '⚠️ **This PR significantly degrades performance. Please optimize before merging.**' : ''}

            [View Full Report](${perf.report_url})`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

            // Fail check if performance degrades significantly
            if (perf.score_delta < -10) {
              core.setFailed('Performance degraded by more than 10 points');
            }
```

<Warning>
  This workflow will:
  - **Block merge** if performance score drops >10 points
  - **Warn** on any performance regression
  - **Celebrate** improvements with green indicators
</Warning>

## Performance Testing Locally

### Step 9: Local Performance Testing

Test performance before deploying:

```bash
# In cn TUI mode:
"Run production build and measure bundle sizes"
```

### Step 10: Pre-commit Performance Checks

Prevent performance regressions before they happen:

```bash
# In cn TUI mode:
"Add pre-commit hooks for bundle size limits"
```

## Performance Troubleshooting

### Debug Performance Issues

Identify and fix performance bottlenecks:

```bash
# In cn TUI mode:
"Why did my performance score drop?"
```

### Performance Issue Quick Fixes

| Issue | Quick Fix Command (in cn TUI) |
|-------|--------------------------------|
| Slow LCP | `"Preload critical resources"` |
| High CLS | `"Add size attributes to images"` |
| Large bundles | `"Implement code splitting"` |
| Slow builds | `"Enable build caching"` |
| Poor caching | `"Configure cache headers"` |

## What You've Accomplished

<Card title="Performance-First Development" icon="gauge-high">
  You've built an AI-powered performance optimization system that:
  - Automatically monitors Core Web Vitals
  - Runs A/B tests between branches
  - Blocks deployments that degrade performance
  - Provides actionable optimization suggestions
</Card>

## Performance Best Practices

The Netlify Performance Rules enforce:

✅ **Build Optimization**
- Dependency caching enabled
- Parallel builds when possible
- Incremental compilation
- Smart cache invalidation

✅ **Runtime Performance**
- Automatic image optimization
- Efficient resource hints (preload, prefetch)
- Optimal cache headers
- CDN configuration

✅ **Monitoring Standards**
- Performance budgets enforced
- Core Web Vitals tracking
- Real user monitoring
- Automated alerts

## Advanced Performance Strategies

### Progressive Enhancement
```bash
# In cn TUI mode:
"Implement progressive enhancement with basic HTML first"
```

### Multi-variant Testing
```bash
# In cn TUI mode:
"Test 3 bundle strategies and auto-select winner"
```

### Predictive Prefetching
```bash
# In cn TUI mode:
"Analyze navigation patterns and prefetch next pages"
```

## Next Steps

- Install [Netlify MCP](https://hub.continue.dev/netlify/netlify-mcp) from Continue Hub
- Set up [Performance Monitoring](https://docs.netlify.com/analytics/get-started/)
- Configure [A/B Testing](https://docs.netlify.com/split-testing/overview/)
- Join the [Continue Discord](https://discord.gg/continue) for support

## Resources

- [Netlify MCP on Continue Hub](https://hub.continue.dev/netlify/netlify-mcp)
- [Core Web Vitals Guide](https://web.dev/vitals/)
- [Netlify Analytics Documentation](https://docs.netlify.com/analytics/)
- [Continue Performance Guides](https://docs.continue.dev/guides)